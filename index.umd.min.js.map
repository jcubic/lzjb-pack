{"version":3,"file":"index.umd.min.js","sources":["src/lzjb.js"],"sourcesContent":["/*\n * source https://github.com/copy/jslzjb-k\n * Based on jslzjb: https://code.google.com/p/jslzjb/\n * Heavily modified for speed\n */\n// Constants was used for compress/decompress function.\nconst\n/** @const */ NBBY = 8,\n      /** @const */ MATCH_BITS = 6,\n      /** @const */ MATCH_MIN = 3,\n      /** @const */ MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),\n      /** @const */ OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),\n      /** @const */ LEMPEL_SIZE = 256;\n\n/**\n  * Because of weak of javascript's natural, many compression algorithm\n  * become useless in javascript implementation. The main problem is\n  * performance, even the simple Huffman, LZ77/78 algorithm will take many\n  * many time to operate. We use LZJB algorithm to do that, it suprisingly\n  * fulfills our requirement to compress string fastly and efficiently.\n  *\n  * Our implementation is based on\n  * http://src.opensolaris.org/source/raw/onnv/onnv-gate/\n  * usr/src/uts/common/os/compress.c\n  * It is licensed under CDDL.\n  *\n  * Compress byte array using fast and efficient algorithm.\n  *\n  * @param {Uint8Array} sstart  The buffer to compress\n  * @param {Uint8Array} dstart  The buffer to write into\n  * @return {number} compressed length (number of bytes written to the\n  *                  output buffer). May be bigger than the size of the\n  *                  output buffer, in which case some bytes are lost\n  */\nfunction compress(sstart, dstart) {\n    var slen = 0,\n        src = 0,\n        dst = 0,\n        cpy = 0,\n        copymap = 0,\n        copymask = 1 << (NBBY - 1),\n        mlen = 0,\n        offset = 0,\n        hp = 0,\n        lempel = new Int32Array(LEMPEL_SIZE),\n        i = 0;\n\n    // Initialize lempel array.\n    for(i = 0; i < LEMPEL_SIZE; i++) {\n        lempel[i] = -858993460;\n    }\n\n    slen = sstart.length;\n\n    while (src < slen) {\n        if ((copymask <<= 1) == (1 << NBBY)) {\n            copymask = 1;\n            copymap = dst;\n            dstart[dst++] = 0;\n        }\n\n        if (src > slen - MATCH_MAX) {\n            dstart[dst++] = sstart[src++];\n            continue;\n        }\n\n        hp = ((sstart[src] + 13) ^\n              (sstart[src + 1] - 13) ^\n              sstart[src + 2]) &\n            (LEMPEL_SIZE - 1);\n\n        offset = (src - lempel[hp]) & OFFSET_MASK;\n        lempel[hp] = src;\n        cpy = src - offset;\n\n        if (cpy >= 0 && cpy != src &&\n            sstart[src] == sstart[cpy] &&\n            sstart[src + 1] == sstart[cpy + 1] &&\n            sstart[src + 2] == sstart[cpy + 2]) {\n            dstart[copymap] |= copymask;\n            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++)\n                if (sstart[src + mlen] != sstart[cpy + mlen])\n                    break;\n            dstart[dst++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |\n                (offset >> NBBY);\n            dstart[dst++] = offset;\n            src += mlen;\n        } else {\n            dstart[dst++] = sstart[src++];\n        }\n    }\n\n    console.assert(sstart.length >= src);\n\n    return dst;\n}\n\n/**\n  * Our implementation is based on\n  * http://src.opensolaris.org/source/raw/onnv/onnv-gate/\n  * usr/src/uts/common/os/compress.c\n  * It is licensed under CDDL.\n  *\n  * Decompress byte array using fast and efficient algorithm.\n  *\n  * @param {Uint8Array} sstart  The buffer to decompress\n  * @param {number} slen  compressed length\n  * @param {Uint8Array} dstart  The buffer to write into\n  * @return {number} decompressed length\n  */\nfunction decompress(sstart, slen, dstart) {\n    slen = slen | 0;\n\n    var src = 0,\n        dst = 0,\n        cpy = 0,\n        copymap = 0,\n        copymask = 1 << (NBBY - 1 | 0),\n        mlen = 0,\n        offset = 0;\n\n    //var avg_mlen = [];\n\n    while (src < slen) {\n        if ((copymask <<= 1) === (1 << NBBY)) {\n            copymask = 1;\n            copymap = sstart[src];\n            src = src + 1 | 0;\n        }\n\n        if (copymap & copymask) {\n            mlen = (sstart[src] >> (NBBY - MATCH_BITS | 0)) + MATCH_MIN | 0;\n            offset = ((sstart[src] << NBBY) | sstart[src + 1 | 0]) & OFFSET_MASK;\n            src = src + 2 | 0;\n\n            cpy = dst - offset | 0;\n            //if (cpy >= 0)\n            {\n                //console.log(mlen);\n                //avg_mlen.push(mlen);\n\n                //dstart.set(dstart.subarray(cpy, cpy + mlen | 0), dst);\n                //dst = dst + mlen | 0;\n                //cpy = cpy + mlen | 0;\n\n                //mlen = mlen - 1 | 0;\n                while (mlen > 4) {\n                    dstart[dst] = dstart[cpy];\n                    dst = dst + 1 | 0;\n                    cpy = cpy + 1 | 0;\n\n                    dstart[dst] = dstart[cpy];\n                    dst = dst + 1 | 0;\n                    cpy = cpy + 1 | 0;\n\n                    dstart[dst] = dstart[cpy];\n                    dst = dst + 1 | 0;\n                    cpy = cpy + 1 | 0;\n\n                    dstart[dst] = dstart[cpy];\n                    dst = dst + 1 | 0;\n                    cpy = cpy + 1 | 0;\n\n                    mlen = mlen - 4 | 0;\n                }\n\n                while (mlen > 0) {\n                    dstart[dst] = dstart[cpy];\n                    dst = dst + 1 | 0;\n                    cpy = cpy + 1 | 0;\n                    mlen = mlen - 1 | 0;\n                }\n            }\n            //else\n            //{\n            //    /*\n            //     * offset before start of destination buffer\n            //     * indicates corrupt source data\n            //     */\n            //    console.warn(\"possibly corrupt data\");\n            //    return dstart;\n            //}\n        } else {\n            dstart[dst] = sstart[src];\n            dst = dst + 1 | 0;\n            src = src + 1 | 0;\n        }\n    }\n\n    //console.log(avg_mlen.reduce(function(a, x) { return a + x; }, 0) / avg_mlen.length);\n\n    //console.assert(dstart.length >= dst);\n    //console.assert(sstart.length >= src);\n\n    return dst;\n}\n\n\nfunction encode_magic() {\n    const encoder = new TextEncoder('utf-8');\n    return encoder.encode(MAGIC_STRING);\n}\n\nconst MAGIC_STRING = '@lzjb';\nconst MAGIC = encode_magic();\n\nfunction merge_uint8_array(...args) {\n    if (args.length > 1) {\n        const len = args.reduce((acc, arr) => acc + arr.length, 0);\n        const result = new Uint8Array(len);\n        let offset = 0;\n        args.forEach(item => {\n            result.set(item, offset);\n            offset += item.length;\n        });\n        return result;\n    } else if (args.length) {\n        return args[0];\n    }\n}\n\nfunction number_to_bytes(number) {\n    const len = Math.ceil(Math.log2(number) / 8);\n    const byteArray = new Uint8Array(len);\n\n    for (let index = 0; index < byteArray.length; index ++ ) {\n        const byte = number & 0xff;\n        byteArray[index] = byte;\n        number = (number - byte) / 256;\n    }\n\n    return byteArray;\n}\n\nfunction bytes_to_number(byteArray) {\n    let result = 0;\n    for (let i = byteArray.length - 1; i >= 0; i--) {\n        result = (result * 256) + byteArray[i];\n    }\n\n    return result;\n}\n\nfunction pack(input, { magic = true } = {}) {\n    const out = new Uint8Array(Math.max(input.length * 1.5 | 0, 16 * 1024));\n    const len = compress(input, out);\n    const len_array = number_to_bytes(input.length);\n    const payload = [\n        Uint8Array.of(len_array.length),\n        len_array,\n        out.slice(0, len)\n    ];\n    if (magic) {\n        payload.unshift(MAGIC);\n    }\n    return merge_uint8_array(...payload);\n}\n\nfunction unpack(input, { magic = true } = {}) {\n    if (magic) {\n        const decoder = new TextDecoder('utf-8');\n        const magic_prefix = decoder.decode(input.slice(0, MAGIC.length));\n        if (magic_prefix !== MAGIC_STRING) {\n            throw new Error('Invalid magic value');\n        }\n    }\n    const magic_length = magic ? MAGIC.length : 0;\n    const size = input[magic_length];\n    const start = magic_length + 1;\n    const end = magic_length + size + 1;\n    const len = bytes_to_number(input.slice(start, end));\n    input = input.slice(end);\n    const out = new Uint8Array(len);\n    decompress(input, input.length, out);\n    return out;\n}\n\nexport { pack, unpack };\n"],"names":["MAGIC_STRING","MAGIC","TextEncoder","encode","input","magic","out","Uint8Array","Math","max","length","len","sstart","dstart","slen","src","dst","cpy","copymap","copymask","mlen","offset","hp","lempel","Int32Array","i","console","assert","compress","len_array","number","ceil","log2","byteArray","index","byte","number_to_bytes","payload","of","slice","unshift","args","reduce","acc","arr","result","forEach","item","set","merge_uint8_array","TextDecoder","decode","Error","magic_length","start","end","bytes_to_number","decompress"],"mappings":"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"}